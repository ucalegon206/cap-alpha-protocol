import yaml
import os
from pathlib import Path

# Paths
CONTRACTS_DIR = Path(__file__).parent
SCHEMA_YAML = CONTRACTS_DIR / "schema.yaml"
SCHEMA_SQL = CONTRACTS_DIR / "schema.sql"
TYPES_TS = CONTRACTS_DIR / "types.ts"

# Type Mappings
# YAML Type -> SQL Type
SQL_TYPE_MAP = {
    "VARCHAR": "VARCHAR",
    "INTEGER": "INTEGER",
    "FLOAT": "FLOAT", 
    "BOOLEAN": "BOOLEAN",
    "DATE": "DATE",
    "TIMESTAMP": "TIMESTAMP"
}

# YAML Type -> TypeScript Type
TS_TYPE_MAP = {
    "VARCHAR": "string",
    "INTEGER": "number",
    "FLOAT": "number",
    "BOOLEAN": "boolean",
    "DATE": "string",
    "TIMESTAMP": "string"
}

def load_schema():
    with open(SCHEMA_YAML, "r") as f:
        return yaml.safe_load(f)

def generate_sql(schema):
    """Generates DuckDB-compatible SQL DDL."""
    sql_lines = ["-- AUTO-GENERATED BY contracts/compile.py", "-- DO NOT EDIT MANUALLY", ""]
    
    for table_name, table_def in schema.get("tables", {}).items():
        description = table_def.get("description", "")
        if description:
            sql_lines.append(f"-- {description}")
        
        sql_lines.append(f"CREATE TABLE IF NOT EXISTS {table_name} (")
        columns = table_def.get("columns", {})
        col_defs = []
        
        for col_name, col_def in columns.items():
            col_type = col_def.get("type", "VARCHAR")
            sql_type = SQL_TYPE_MAP.get(col_type, "VARCHAR")
            # Handle identifiers with spaces
            safe_col_name = f'"{col_name}"' if " " in col_name else col_name
            col_defs.append(f"    {safe_col_name} {sql_type}")
        
        sql_lines.append(",\n".join(col_defs))
        sql_lines.append(");\n")
    
    return "\n".join(sql_lines)

def generate_ts(schema):
    """Generates TypeScript interfaces."""
    ts_lines = ["// AUTO-GENERATED BY contracts/compile.py", "// DO NOT EDIT MANUALLY", ""]
    
    for table_name, table_def in schema.get("tables", {}).items():
        # Convert snake_case table name to PascalCase interface name
        interface_name = "".join(x.title() for x in table_name.split("_"))
        description = table_def.get("description", "")
        
        if description:
            ts_lines.append(f"/** {description} */")
        
        ts_lines.append(f"export interface {interface_name} {{")
        
        columns = table_def.get("columns", {})
        for col_name, col_def in columns.items():
            if " " in col_name:
                # TS interfaces can't easily handle spaces without index signatures, 
                # but for simplicity we'll try to map it or skip it.
                # Ideally, we should normalize these in Bronze/Silver.
                # For now, we'll quote it.
                safe_col_name = f'"{col_name}"'
            else:
                safe_col_name = col_name
                
            col_type = col_def.get("type", "VARCHAR")
            ts_type = TS_TYPE_MAP.get(col_type, "any")
            col_desc = col_def.get("description", "")
            
            if col_desc:
                ts_lines.append(f"  /** {col_desc} */")
            ts_lines.append(f"  {safe_col_name}: {ts_type};")
            
        ts_lines.append("}\n")
    
    return "\n".join(ts_lines)

def main():
    print(f"Loading schema from {SCHEMA_YAML}...")
    schema = load_schema()
    
    print(f"Generating SQL to {SCHEMA_SQL}...")
    sql_content = generate_sql(schema)
    with open(SCHEMA_SQL, "w") as f:
        f.write(sql_content)
        
    print(f"Generating TypeScript to {TYPES_TS}...")
    ts_content = generate_ts(schema)
    with open(TYPES_TS, "w") as f:
        f.write(ts_content)
        
    print("Done.")

if __name__ == "__main__":
    main()
